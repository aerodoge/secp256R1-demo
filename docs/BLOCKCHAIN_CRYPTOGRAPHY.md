# 区块链密码学详解

从原理到实践，以 BTC、ETH、SOL 为案例分析。

---

## 目录

1. [密码学基础](#1-密码学基础)
2. [哈希函数](#2-哈希函数)
3. [椭圆曲线密码学 (ECC)](#3-椭圆曲线密码学-ecc)
4. [数字签名](#4-数字签名)
5. [BTC 密码学案例](#5-btc-密码学案例)
6. [ETH 密码学案例](#6-eth-密码学案例)
7. [SOL 密码学案例](#7-sol-密码学案例)
8. [三链对比总结](#8-三链对比总结)
9. [Passkey 与 secp256r1](#9-passkey-与-secp256r1)

---

## 1. 密码学基础

### 1.1 区块链中密码学的作用

| 功能    | 密码学技术   | 用途        |
|-------|---------|-----------|
| 身份验证  | 数字签名    | 证明交易发起者身份 |
| 数据完整性 | 哈希函数    | 确保数据未被篡改  |
| 地址生成  | 哈希 + 编码 | 从公钥派生地址   |
| 区块链接  | 哈希函数    | 区块通过哈希值链接 |
| 工作量证明 | 哈希函数    | PoW 挖矿    |
| 隐私保护  | 零知识证明   | 隐藏交易细节    |

### 1.2 对称 vs 非对称加密

```
对称加密 (AES, DES):
┌─────────┐    同一把钥匙    ┌─────────┐
│ 加密     │ ──────────────→ │ 解密    │
└─────────┘                  └─────────┘
     问题: 如何安全传输密钥?

非对称加密 (RSA, ECC):
┌─────────┐    公钥加密      ┌─────────┐
│ 发送方   │ ──────────────→ │ 接收方  │
└─────────┘    私钥解密      └─────────┘
     优势: 公钥可公开，私钥保密
```

**区块链选择非对称加密的原因:**

- 私钥永不传输，降低泄露风险
- 公钥可公开，便于验证签名
- 支持数字签名，证明身份

---

## 2. 哈希函数

### 2.1 哈希函数的特性

| 特性   | 描述               | 重要性   |
|------|------------------|-------|
| 确定性  | 相同输入永远产生相同输出     | 验证一致性 |
| 单向性  | 无法从输出反推输入        | 安全性基础 |
| 雪崩效应 | 输入微小变化导致输出巨大变化   | 防篡改   |
| 抗碰撞  | 极难找到两个不同输入产生相同输出 | 唯一性   |
| 固定长度 | 任意长度输入产生固定长度输出   | 存储效率  |

### 2.2 区块链常用哈希函数

#### SHA-256 (Secure Hash Algorithm 256-bit)

```
输入: "Hello"
输出: 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969 (64 hex = 256 bit)

输入: "Hello."  (仅多一个点)
输出: 2d8bd7d9bb5f85ba643f0110d50cb506a1fe439e769a22503193ea6046bb87f7 (完全不同)
```

**SHA-256 在 BTC 中的应用:**

- 区块哈希 (双重 SHA-256)
- 交易 ID (TXID)
- Merkle 树
- 挖矿 (工作量证明)

#### Keccak-256 (SHA-3 变体)

```
注意: ETH 使用的是 Keccak-256，不是标准 SHA-3
     两者内部参数不同，输出也不同
```

**Keccak-256 在 ETH 中的应用:**

- 地址生成
- 交易哈希
- 合约存储 slot 计算
- ABI 函数选择器

#### RIPEMD-160

```
输出长度: 160 bit (40 hex)
用途: BTC 地址生成 (与 SHA-256 配合)
```

### 2.3 哈希在区块链中的应用

#### 区块链接

```
Block N-1                    Block N                      Block N+1
┌──────────────────┐        ┌──────────────────┐        ┌──────────────────┐
│ Header           │        │ Header           │        │ Header           │
│ - Prev Hash: ... │───────→│ - Prev Hash: H(N-1)───────→│ - Prev Hash: H(N)│
│ - Merkle Root    │        │ - Merkle Root    │        │ - Merkle Root    │
│ - Nonce          │        │ - Nonce          │        │ - Nonce          │
├──────────────────┤        ├──────────────────┤        ├──────────────────┤
│ Transactions     │        │ Transactions     │        │ Transactions     │
└──────────────────┘        └──────────────────┘        └──────────────────┘

篡改 Block N 的数据 → Block N 哈希改变 → Block N+1 的 Prev Hash 不匹配 → 篡改被发现
```

#### Merkle 树

```
                    Merkle Root
                    H(H12 + H34)
                   /            \
              H12                 H34
           H(H1+H2)            H(H3+H4)
            /    \              /    \
          H1      H2          H3      H4
          |       |           |       |
         Tx1     Tx2         Tx3     Tx4

优势:
- 快速验证某笔交易是否在区块中 (O(log n))
- 轻节点只需下载 Merkle 路径，无需全部交易
```

---

## 3. 椭圆曲线密码学 (ECC)

### 3.1 为什么选择 ECC

| 加密方式 | 等效安全强度  | 密钥长度     |
|------|---------|----------|
| RSA  | 128 bit | 3072 bit |
| ECC  | 128 bit | 256 bit  |

**ECC 优势:**

- 更短的密钥长度
- 更快的计算速度
- 更小的存储空间
- 同等安全性下效率更高

### 3.2 椭圆曲线数学基础

#### 椭圆曲线方程

```
Weierstrass 形式: y² = x³ + ax + b (mod p)

示例 secp256k1 (BTC/ETH):
y² = x³ + 7 (mod p)
其中 p = 2²⁵⁶ - 2³² - 977
```

#### 曲线上的点运算

```
椭圆曲线上的"加法"定义:

      P + Q = R

      y
      │
      │         P
      │        ╱
      │       ╱
      │      ╱
      │     Q
      │    ╱
      │   ╱ (P和Q的连线)
      │  ╱
      │ R'  ← 连线与曲线的第三个交点
      │╱
──────┼──────────────────── x
      │
      │ R   ← R' 关于 x 轴的对称点 (最终结果)
      │

规则: P 和 Q 连线与曲线相交于 R'，R' 关于 x 轴对称的点为 R
```

#### 为什么 R 一定在曲线上？

**这是椭圆曲线加法的核心性质：封闭性。**

```
数学证明要点:

1. 直线与三次曲线的交点
   - 椭圆曲线方程 y² = x³ + ax + b 是三次方程
   - 一条直线与三次曲线最多有 3 个交点
   - 已知 P 和 Q 在曲线上 (2 个交点)
   - 第三个交点 R' 必然存在且在曲线上

2. 关于 x 轴对称
   - 如果 (x, y) 在曲线上，则 (x, -y) 也在曲线上
   - 因为 y² = (-y)²
   - 所以 R' 的对称点 R 也在曲线上
```

**代数验证:**

```
设曲线: y² = x³ + ax + b
设直线: y = mx + c (过 P 和 Q)

联立方程，消去 y:
(mx + c)² = x³ + ax + b
x³ - m²x² + (a - 2mc)x + (b - c²) = 0

根据韦达定理 (三个根 x₁, x₂, x₃):
x₁ + x₂ + x₃ = m²

已知 x₁ = Px, x₂ = Qx
则 x₃ = m² - Px - Qx  ← 这就是 R' 的 x 坐标

R 的坐标:
Rx = m² - Px - Qx
Ry = -(m·Rx + c)  ← 取负号得到 R (对称点)
```

**特殊情况处理:**

| 情况            | 处理方式                 |
|---------------|----------------------|
| P = Q         | 使用曲线在 P 点的切线（点倍乘）    |
| P = -Q (互为逆元) | 结果为"无穷远点" O（单位元）     |
| P 或 Q 为 O     | P + O = P, O + Q = Q |

**群的性质 (椭圆曲线加法群):**

```
1. 封闭性: P, Q 在曲线上 → P + Q 也在曲线上 ✓
2. 结合律: (P + Q) + R = P + (Q + R) ✓
3. 单位元: 存在无穷远点 O，P + O = P ✓
4. 逆元: 对任意 P，存在 -P，使 P + (-P) = O ✓
5. 交换律: P + Q = Q + P ✓ (阿贝尔群)
```

> 这使得椭圆曲线上的点构成一个**阿贝尔群（加法群）**，是密码学应用的数学基础。

#### 标量乘法 (核心操作)

```
k × G = P

其中:
- G: 生成元 (曲线上的固定基点)
- k: 私钥 (256 bit 随机数)
- P: 公钥 (曲线上的点)

计算: k × G = G + G + G + ... + G (k 次)

特性:
- 正向计算: 已知 k 和 G，计算 P 很快 (O(log k))
- 反向计算: 已知 P 和 G，求 k 极难 (椭圆曲线离散对数问题 ECDLP)
```

### 3.3 区块链常用曲线

#### secp256k1 (BTC, ETH)

```
参数:
- 方程: y² = x³ + 7
- 素数 p: 2²⁵⁶ - 2³² - 977
- 阶 n: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
- 生成元 G: (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
            0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8)

特点:
- Koblitz 曲线，系数简单 (a=0, b=7)
- 非 NIST 标准曲线
- 计算效率高
```

#### secp256r1 / P-256 / prime256v1 (Passkey, TLS)

```
参数:
- 方程: y² = x³ - 3x + b
- 素数 p: 2²⁵⁶ - 2²²⁴ + 2¹⁹² + 2⁹⁶ - 1
- 生成元 G: (不同于 secp256k1)

特点:
- NIST 标准曲线
- 被 WebAuthn/Passkey 采用
- 硬件加速支持广泛 (Secure Enclave, TPM)
- 本项目使用的曲线
```

#### Ed25519 (SOL, Cosmos)

```
基于: Curve25519 的扭曲爱德华曲线
方程: -x² + y² = 1 + dx²y²

特点:
- 签名速度极快
- 抗侧信道攻击
- 签名确定性 (不需要随机数)
- 公钥 32 字节，签名 64 字节
```

### 3.4 曲线对比

| 特性    | secp256k1 | secp256r1 | Ed25519 |
|-------|-----------|-----------|---------|
| 使用链   | BTC, ETH  | Passkey   | SOL     |
| 私钥长度  | 32 字节     | 32 字节     | 32 字节   |
| 公钥长度  | 33/65 字节  | 33/65 字节  | 32 字节   |
| 签名长度  | 64-72 字节  | 64-72 字节  | 64 字节   |
| 签名算法  | ECDSA     | ECDSA     | EdDSA   |
| 随机数依赖 | 是         | 是         | 否       |
| 标准组织  | SECG      | NIST      | IETF    |
| 硬件加速  | 有限        | 广泛        | 有限      |

---

## 4. 数字签名

### 4.1 签名的作用

```
发送方                                           接收方
┌─────────────────┐                            ┌─────────────────┐
│ 1. 准备消息 M    │                            │ 5. 收到 (M, sig)│
│ 2. 用私钥签名     │ ────────────────────────→  │ 6. 用公钥验证   │
│    sig = Sign(M,│       传输 (M, sig)         │    Verify(M,sig,│
│           priv) │                            │           pub)  │
└─────────────────┘                            └─────────────────┘

签名证明:
1. 身份认证: 消息确实由私钥持有者发送
2. 不可否认: 发送者无法否认发送过消息
3. 完整性: 消息在传输中未被篡改
```

### 4.2 ECDSA (Elliptic Curve Digital Signature Algorithm)

BTC 和 ETH 使用的签名算法。

#### 签名过程

```python
def ecdsa_sign(message, private_key):
    # 1. 计算消息哈希
    z = hash(message)  # 256 bit

    # 2. 生成随机数 k (关键!)
    k = random(1, n-1)  # n 是曲线的阶

    # 3. 计算 R = k × G
    R = k * G
    r = R.x mod n  # 取 R 的 x 坐标

    # 4. 计算 s
    s = k⁻¹ × (z + r × private_key) mod n

    return (r, s)
```

#### 验证过程

```python
def ecdsa_verify(message, signature, public_key):
    r, s = signature
    z = hash(message)

    # 计算
    w = s⁻¹ mod n
    u1 = z × w mod n
    u2 = r × w mod n

    # 恢复点
    P = u1 × G + u2 × public_key

    # 验证
    return P.x mod n == r
```

#### ECDSA 安全要点

```
随机数 k 的重要性:

如果 k 泄露或重复使用:
  s = k⁻¹ × (z + r × private_key)

  已知: s, k, z, r
  可计算: private_key = (s × k - z) × r⁻¹

著名案例:
- 2010 年 Sony PS3 签名漏洞: 固定使用 k=4
- 导致 PS3 私钥被逆向计算出来
```

#### RFC 6979: 确定性 ECDSA

**问题**: 原始 ECDSA 依赖随机数 k，存在安全隐患。

**解决方案**: RFC 6979 标准定义了确定性 k 生成方式。

```python
# RFC 6979 确定性 k 生成
def generate_k_rfc6979(private_key, message_hash):
    # k 由私钥和消息哈希确定性派生
    k = HMAC_SHA256(private_key, message_hash)
    return k

# 特点:
# - 相同私钥 + 相同消息 → 相同 k → 相同签名
# - 不同消息 → 不同 k (安全)
# - 无需随机数生成器
```

**实际验证:**

```javascript
// 使用 ethers.js 测试
const wallet = new ethers.Wallet(privateKey);
const message = "Hello";

const sig1 = await wallet.signMessage(message);
const sig2 = await wallet.signMessage(message);

console.log(sig1 === sig2);  // true - 签名相同!
```

**现代钱包实现:**

| 钱包/库        | k 生成方式   | 同一消息签名    |
|-------------|----------|-----------|
| MetaMask    | RFC 6979 | 确定性 (相同)  |
| go-ethereum | RFC 6979 | 确定性 (相同)  |
| ethers.js   | RFC 6979 | 确定性 (相同)  |
| 原始 ECDSA    | 随机       | 非确定性 (不同) |

> **注意**: 虽然 ECDSA 算法本身允许随机 k，但现代ETH钱包都使用RFC 6979，
> 因此**实际签名是确定性的**，同一笔交易多次签名结果相同。

### 4.3 EdDSA (Edwards-curve Digital Signature Algorithm)

SOL 使用的签名算法，基于 Ed25519。

#### 与 ECDSA 的关键区别

```
原始 ECDSA:
- k 是随机生成的
- 同一消息多次签名，结果不同
- 随机数生成器质量影响安全性

RFC 6979 ECDSA (现代实现):
- k = HMAC(private_key, message_hash)
- 同一消息多次签名，结果相同
- 不依赖随机数生成器

EdDSA:
- k = Hash(private_key || message)
- 同一消息多次签名，结果相同 (确定性)
- 算法设计上就是确定性的 (不是后期补丁)
- 更安全，不存在 k 重用问题
```

#### EdDSA 签名过程

```python
def eddsa_sign(message, private_key):
    # 1. 扩展私钥
    h = SHA512(private_key)
    a = h[0:32]  # 标量
    prefix = h[32:64]  # 用于生成 r

    # 2. 确定性计算 r (关键区别!)
    r = SHA512(prefix || message) mod n

    # 3. 计算 R = r × G
    R = r * G

    # 4. 计算 s
    k = SHA512(R || public_key || message) mod n
    s = (r + k × a) mod n

    return (R, s)  # 64 字节签名
```

---

## 5. BTC 密码学案例

### 5.1 密码学组件总览

```
┌─────────────────────────────────────────────────────────────┐
│                        Bitcoin                              │
├─────────────────────────────────────────────────────────────┤
│  私钥生成          256 bit 随机数                             │
│       ↓                                                     │
│  公钥计算          secp256k1: P = k × G                      │
│       ↓                                                     │
│  地址生成          SHA256 → RIPEMD160 → Base58Check          │
│       ↓                                                     │
│  交易签名          ECDSA (后支持 Schnorr)                     │
│       ↓                                                     │
│  区块哈希          SHA256(SHA256(block_header))              │
│       ↓                                                     │
│  挖矿              寻找 nonce 使 hash < target                │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 地址生成流程

```
步骤 1: 生成私钥
┌─────────────────────────────────────────────────────────────────────┐
│ 私钥 (256 bit 随机数):                                                │
│ e9873d79c6d87dc0fb6a5778633389f4453213303da61f20bd67fc233aa33262    │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
步骤 2: 计算公钥 (secp256k1)
┌─────────────────────────────────────────────────────────────────────┐
│ 公钥 = 私钥 × G                                                      │
│ 未压缩 (65 字节): 04 + x(32字节) + y(32字节)                           │
│ 压缩 (33 字节): 02/03 + x(32字节)  (02=y为偶, 03=y为奇)                │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
步骤 3: SHA256 哈希
┌─────────────────────────────────────────────────────────────────────┐
│ SHA256(公钥) → 32 字节                                               │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
步骤 4: RIPEMD160 哈希
┌─────────────────────────────────────────────────────────────────────┐
│ RIPEMD160(SHA256结果) → 20 字节 (公钥哈希)                             │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
步骤 5: 添加版本前缀
┌─────────────────────────────────────────────────────────────────────┐
│ 0x00 + 公钥哈希 (主网)                                                │
│ 0x05 + 脚本哈希 (P2SH)                                               │
│ 0x6F + 公钥哈希 (测试网)                                              │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
步骤 6: 计算校验和
┌─────────────────────────────────────────────────────────────────────┐
│ checksum = SHA256(SHA256(version + payload))[0:4]                   │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
步骤 7: Base58Check 编码
┌─────────────────────────────────────────────────────────────────────┐
│ Base58(version + payload + checksum)                                │
│ 结果: 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2                            │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.3 交易签名

```
交易结构:
┌─────────────────────────────────────────┐
│ Version: 1                              │
│ Inputs:                                 │
│   - Previous TX Hash                    │
│   - Output Index                        │
│   - ScriptSig (签名 + 公钥)              │
│   - Sequence                            │
│ Outputs:                                │
│   - Value (satoshis)                    │
│   - ScriptPubKey (锁定脚本)              │
│ Locktime                                │
└─────────────────────────────────────────┘

签名过程:
1. 构造待签名的交易数据
2. 双重 SHA256: z = SHA256(SHA256(tx_data))
3. ECDSA 签名: (r, s) = Sign(z, private_key)
4. DER 编码签名: 30 [len] 02 [rlen] [r] 02 [slen] [s] [hashtype]
```

### 5.4 Schnorr 签名 (Taproot 升级)

2021 年 Taproot 升级引入 Schnorr 签名 (BIP 340)。

```
Schnorr vs ECDSA:

| 特性 | ECDSA | Schnorr |
|------|-------|---------|
| 签名聚合 | 不支持 | 支持 (多签合一) |
| 签名大小 | 72 字节 | 64 字节 |
| 批量验证 | 不支持 | 支持 (更高效) |
| 线性性 | 否 | 是 |

Schnorr 优势:
- 多签交易只需一个签名 (节省空间和 gas)
- 批量验证更快
- 更好的隐私性 (多签看起来像单签)
```

### 5.5 工作量证明 (PoW)

```
挖矿目标:
找到 nonce，使得 SHA256(SHA256(block_header)) < target

block_header:
┌─────────────────────────────────────┐
│ version (4 bytes)                   │
│ prev_block_hash (32 bytes)          │
│ merkle_root (32 bytes)              │
│ timestamp (4 bytes)                 │
│ bits (4 bytes) ← 难度目标            │
│ nonce (4 bytes) ← 矿工调整这个值      │
└─────────────────────────────────────┘

示例:
target: 0x00000000000000000004b3c5...
需要找到 nonce 使哈希值前导零足够多
平均需要 2^72 次哈希运算 (当前难度)
```

---

## 6. ETH 密码学案例

### 6.1 密码学组件总览

```
┌─────────────────────────────────────────────────────────────┐
│                        Ethereum                             │
├─────────────────────────────────────────────────────────────┤
│  私钥生成          256 bit 随机数                             │
│       ↓                                                     │
│  公钥计算          secp256k1: P = k × G                      │
│       ↓                                                     │
│  地址生成          Keccak256(公钥)[12:32] → 20 字节            │
│       ↓                                                     │
│  交易签名          ECDSA + EIP-155 (链 ID 保护)               │
│       ↓                                                     │
│  合约地址          Keccak256(rlp([sender, nonce]))           │
│       ↓                                                     │
│  状态存储          Merkle Patricia Trie                      │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 地址生成流程

```
步骤 1: 生成私钥 (与 BTC 相同)
┌─────────────────────────────────────────────────────────────────────┐
│ 私钥 (256 bit):                                                     │
│ 0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318  │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
步骤 2: 计算公钥 (secp256k1，与 BTC 相同)
┌─────────────────────────────────────────────────────────────────────┐
│ 公钥 = 私钥 × G                                                      │
│ 取未压缩公钥的 x,y 坐标 (去掉 04 前缀): 64 字节                          │  
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
步骤 3: Keccak256 哈希 (与 BTC 不同!)
┌─────────────────────────────────────────────────────────────────────┐
│ Keccak256(公钥) → 32 字节                                            │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
步骤 4: 取后 20 字节
┌─────────────────────────────────────────────────────────────────────┐
│ 地址 = hash[12:32] → 20 字节                                         │
│ 结果: 0x2c7536E3605D9C16a7a3D7b1898e529396a65c23                     │
└─────────────────────────────────────────────────────────────────────┘

注意: ETH 地址没有校验和，但 EIP-55 定义了大小写混合的校验和格式
```

### 6.3 EIP-55 校验和地址

#### 问题背景

ETH 地址本身**没有校验和**（不像 BTC 的 Base58Check）：

```
ETH 地址: 0x5aaeb6053f3e94c9b9a09f33669435e7ef1beaed (全小写)

问题: 如果用户输错一个字符，系统无法检测
→ 资金可能发送到错误地址，永久丢失
```

#### 解决方案：大小写作为校验和

**核心思想**: 用 Keccak256 哈希值决定每个字母的大小写。

```
步骤 1: 计算地址的哈希
address = "5aaeb6053f3e94c9b9a09f33669435e7ef1beaed" (去掉0x，小写)
hash    = Keccak256(address)
        = "1b5fd3e5......"

步骤 2: 逐字符决定大小写
地址字符:  5  a  a  e  b  6  0  5  3  f  3  e  9  4  c  9 ...
哈希字符:  1  b  5  f  d  3  e  5  ...
           ↓  ↓  ↓  ↓  ↓
规则: 哈希字符 >= 8 → 大写，否则小写

位置 0: 地址='5' (数字不变)
位置 1: 地址='a', 哈希='b' (11 >= 8) → 'A' (大写)
位置 2: 地址='a', 哈希='5' (5 < 8)  → 'a' (小写)
位置 3: 地址='e', 哈希='f' (15 >= 8) → 'E' (大写)
...

结果: 0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed
        ↑小↑大    ↑大↑大  ↑小↑大        ↑大  ↑大
```

#### 代码实现

```python
def to_checksum_address(address):
    address = address.lower().replace('0x', '')
    hash = keccak256(address.encode())

    result = '0x'
    for i, char in enumerate(address):
        if char in '0123456789':
            result += char          # 数字不变
        elif int(hash[i], 16) >= 8: # 哈希对应位 >= 8
            result += char.upper()  # 大写
        else:
            result += char.lower()  # 小写

    return result

# 示例:
# 输入: 0x5aaeb6053f3e94c9b9a09f33669435e7ef1beaed
# 输出: 0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed
```

#### 校验原理

```
正确地址: 0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed
                ↑
用户输错: 0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAEd
                                              ↑ e→E 错误

验证过程:
1. 转小写: 5aaeb6053f3e94c9b9a09f33669435e7ef1beaed
2. 计算哈希，重新生成正确的大小写模式
3. 对比发现不匹配 → 地址有误！
```

#### 安全性分析

```
每个字母有 50% 概率大写 (哈希值 8-f) 或小写 (哈希值 0-7)

ETH 地址有 40 个 hex 字符，其中约 30 个是字母 (a-f)
→ 错误地址被误判为有效的概率: (1/2)^30 ≈ 1/10亿

实际效果:
- 输错任意一个字符 → 大小写模式改变 → 校验失败
- 比没有校验和安全得多
```

#### BTC vs ETH 校验和对比

| 特性    | BTC (Base58Check) | ETH (EIP-55) |
|-------|-------------------|--------------|
| 校验方式  | 4 字节显式校验和         | 大小写隐式校验      |
| 地址长度  | 增加 4 字节           | 不变           |
| 错误检测率 | 99.99999998%      | ~99.9999999% |
| 向后兼容  | -                 | 全小写地址仍有效     |

> **注意**: EIP-55 是可选的。全小写地址 `0x5aae...` 仍然有效，
> 只是钱包无法帮你检测输入错误。推荐始终使用校验和格式。

### 6.4 交易签名 (EIP-155)

```
传统签名问题:
- 相同交易在不同链上有效
- 可能被重放攻击

EIP-155 解决方案:
- 签名时包含 chainId
- v 值编码为: v = chainId * 2 + 35 + recovery_id

签名数据结构:
┌──────────────────────────────────────┐
│ RLP([nonce, gasPrice, gasLimit,      │
│      to, value, data, chainId, 0, 0])│
└──────────────────────────────────────┘
                 ↓ Keccak256
┌─────────────────────────────────────┐
│ 消息哈希 (32 字节)                    │
└─────────────────────────────────────┘
                 ↓ ECDSA Sign
┌─────────────────────────────────────┐
│ 签名 (r, s, v)                       │
│ r: 32 字节                           │
│ s: 32 字节                           │
│ v: 1 字节 (恢复公钥用)                │
└─────────────────────────────────────┘
```

### 6.5 合约地址计算

```
方式 1: CREATE (普通部署)
┌─────────────────────────────────────────────────────────────┐
│ contract_address = Keccak256(RLP([sender, nonce]))[12:32]   │
│                                                             │
│ 示例:                                                        │
│ sender = 0x6ac7ea33f8831ea9dcc53393aaa88b25a785dbf0         │
│ nonce = 0                                                   │
│ address = 0xcd234a471b72ba2f1ccf0a70fcaba648a5eecd8d        │
└─────────────────────────────────────────────────────────────┘

方式 2: CREATE2 (确定性部署)
┌─────────────────────────────────────────────────────────────┐
│ contract_address = Keccak256(                               │
│     0xff ++ sender ++ salt ++ Keccak256(init_code)          │
│ )[12:32]                                                    │
│                                                             │
│ 优势: 可预测合约地址，便于反事实部署                              │
└─────────────────────────────────────────────────────────────┘
```

### 6.6 Merkle Patricia Trie

ETH 使用 MPT 存储状态，比 BTC 的 Merkle 树更复杂。

```
结构:
                      Root Hash
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
   Extension Node    Branch Node       Leaf Node
   (共享前缀)        (16 分支)         (键值对)

特点:
- 支持高效的插入、删除、查询
- 每次状态变化只需更新路径上的节点
- 可以证明某个 key 不存在
```

### 6.7 EIP-7212: P256VERIFY 预编译

```
地址: 0x0000000000000000000000000000000000000100
Gas: 3,450 (验证成功) / 6,900 (最大)

输入 (160 字节):
┌──────────────────────────────────────┐
│ message_hash (32 字节)               │
│ r (32 字节)                          │
│ s (32 字节)                          │
│ public_key_x (32 字节)               │
│ public_key_y (32 字节)               │
└──────────────────────────────────────┘

输出:
- 成功: 32 字节，值为 1
- 失败: 空字节

用途: 支持 Passkey (secp256r1) 签名验证
```

---

## 7. SOL 密码学案例

### 7.1 密码学组件总览

```
┌──────────────────────────────────────────────────────────────────────────┐
│                        Solana                                            │
├──────────────────────────────────────────────────────────────────────────┤
│  私钥生成          256 bit 随机数                                          │
│       ↓                                                                  │
│  公钥计算          Ed25519: P = k × G                                      │
│       ↓                                                                  │
│  地址             公钥本身 (32 字节 Base58)                                 │
│       ↓                                                                  │
│  交易签名          EdDSA (Ed25519)                                        │
│       ↓                                                                  │
│  程序地址          SHA256(seeds ++ program_id ++ "ProgramDerivedAddress") │
│       ↓                                                                 │
│  历史证明          SHA256 连续哈希 (PoH)                                   │
└─────────────────────────────────────────────────────────────────────────┘
```

### 7.2 Ed25519 密钥对

```
私钥: 64 字节 (32 字节种子 + 32 字节扩展)
┌─────────────────────────────────────────────────────────────────────┐
│ 种子 (32 字节): 随机数                                                │
│ 扩展: SHA512(种子) → 64 字节                                          │
│   - 前 32 字节: 标量 a (用于签名)                                      │
│   - 后 32 字节: prefix (用于确定性 r 计算)                             │
└─────────────────────────────────────────────────────────────────────┘

公钥: 32 字节
┌─────────────────────────────────────────────────────────────────────┐
│ 公钥 = a × G (压缩点表示)                                             │
│ 直接作为地址使用                                                       │
│ 示例: 7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU                   │
└─────────────────────────────────────────────────────────────────────┘

注意: SOL 地址 = 公钥，没有额外的哈希步骤
```

### 7.3 交易签名

```
SOL 交易结构:
┌─────────────────────────────────────┐
│ Signatures: [sig1, sig2, ...]       │ ← 支持多签
│ Message:                            │
│   - Header                          │
│   - Account Keys                    │
│   - Recent Blockhash                │
│   - Instructions                    │
└─────────────────────────────────────┘

签名过程:
1. 序列化 Message
2. EdDSA 签名: sig = Sign(message, private_key)
3. 签名固定 64 字节，无需编码

验证:
- Ed25519 验证极快
- 支持批量验证 (比逐个验证快 2-3 倍)
```

### 7.4 程序派生地址 (PDA)

```
PDA 特点:
- 不在 Ed25519 曲线上
- 没有对应的私钥
- 只能由程序签名

生成算法:
┌─────────────────────────────────────────────────────────────┐
│ for bump in 255..0:                                         │
│     candidate = SHA256(seeds ++ program_id ++               │
│                        "ProgramDerivedAddress" ++ [bump])   │
│     if candidate is NOT on curve:                           │
│         return (candidate, bump)  # 找到有效 PDA            │
└─────────────────────────────────────────────────────────────┘

用途:
- 程序控制的账户 (无私钥)
- 确定性地址生成
- 跨程序调用时的权限控制
```

### 7.5 历史证明 (Proof of History)

```
PoH 原理:
hash[0] = SHA256(seed)
hash[1] = SHA256(hash[0])
hash[2] = SHA256(hash[1])
...
hash[n] = SHA256(hash[n-1])

特点:
- 顺序执行，无法并行
- 证明时间流逝
- 提供全局时钟

验证:
- 验证者可以并行验证 (切分哈希链)
- 生成慢，验证快
```

### 7.6 SOL vs ETH 签名对比

```go
// ETH: ECDSA (secp256k1)
message := []byte("Hello")
hash := crypto.Keccak256Hash(message)
signature, _ := crypto.Sign(hash.Bytes(), privateKey) // 65 字节

// SOL: EdDSA (Ed25519)
message := []byte("Hello")
signature := ed25519.Sign(privateKey, message) // 64 字节，无需预哈希
```

---

## 8. 三链对比总结

### 8.1 密码学选择对比

| 组件   | BTC               | ETH       | SOL        |
|------|-------------------|-----------|------------|
| 椭圆曲线 | secp256k1         | secp256k1 | Curve25519 |
| 签名算法 | ECDSA / Schnorr   | ECDSA     | EdDSA      |
| 哈希函数 | SHA256, RIPEMD160 | Keccak256 | SHA256     |
| 地址长度 | 25-34 字节 (编码后)    | 20 字节     | 32 字节      |
| 地址格式 | Base58Check       | Hex (0x)  | Base58     |
| 签名长度 | 71-73 字节          | 65 字节     | 64 字节      |

### 8.2 地址生成对比

```
BTC:
私钥 → secp256k1 → 公钥 → SHA256 → RIPEMD160 → Base58Check
                                                     ↓
                                        1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa

ETH:
私钥 → secp256k1 → 公钥 → Keccak256 → 取后20字节
                                          ↓
                         0x742d35Cc6634C0532925a3b844Bc9e7595f0bE27

SOL:
私钥 → Ed25519 → 公钥 (直接作为地址)
                    ↓
         7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU
```

### 8.3 签名流程对比

```
BTC/ETH (ECDSA):
┌──────────────────────────────────────────────────┐
│ 1. z = Hash(message)                             │
│ 2. k = random()  ← 随机数！                      │
│ 3. R = k × G                                     │
│ 4. r = R.x mod n                                 │
│ 5. s = k⁻¹(z + r×priv) mod n                    │
│ 输出: (r, s)                                     │
└──────────────────────────────────────────────────┘

SOL (EdDSA):
┌──────────────────────────────────────────────────┐
│ 1. r = Hash(prefix || message)  ← 确定性！       │
│ 2. R = r × G                                     │
│ 3. k = Hash(R || pub || message)                 │
│ 4. s = r + k × priv mod n                        │
│ 输出: (R, s)                                     │
└──────────────────────────────────────────────────┘
```

### 8.4 安全性对比

| 安全特性   | BTC       | ETH       | SOL       |
|--------|-----------|-----------|-----------|
| 签名确定性  | 否 (ECDSA) | 否 (ECDSA) | 是 (EdDSA) |
| 随机数依赖  | 高         | 高         | 无         |
| k 重用风险 | 有         | 有         | 无         |
| 批量验证   | 有限        | 有限        | 高效        |
| 抗侧信道   | 一般        | 一般        | 强         |

### 8.5 性能对比

| 指标   | secp256k1 (BTC/ETH) | Ed25519 (SOL) |
|------|---------------------|---------------|
| 签名速度 | ~10,000/秒           | ~30,000/秒     |
| 验证速度 | ~5,000/秒            | ~15,000/秒     |
| 批量验证 | N/A                 | 更快            |
| 公钥大小 | 33/65 字节            | 32 字节         |
| 签名大小 | 64-72 字节            | 64 字节         |

---

## 9. Passkey 与 secp256r1

### 9.1 为什么 Passkey 使用 secp256r1

```
secp256r1 (P-256) 的优势:
1. NIST 标准曲线，被广泛信任
2. 硬件支持: TPM, Secure Enclave, Android Keystore
3. WebAuthn/FIDO2 标准指定曲线
4. TLS/SSL 默认支持

secp256k1 的问题:
1. 非 NIST 标准
2. 硬件加速支持少
3. WebAuthn 不支持
```

### 9.2 EIP-7212/7951 的意义

```
问题:
- Passkey 使用 secp256r1
- ETH 原生只支持 secp256k1
- 智能合约内验证 secp256r1 非常昂贵 (~1M gas)

解决方案:
- 添加 P256VERIFY 预编译合约
- Gas 消耗降至 ~6,900
- 使 Passkey 签名在链上验证经济可行
```

### 9.3 本项目中的应用

```
本项目架构:

用户设备                          智能合约
┌─────────────────┐              ┌─────────────────┐
│ Secure Enclave  │              │ PasskeyWallet   │
│ ┌─────────────┐ │              │ ┌─────────────┐ │
│ │ secp256r1   │ │  签名        │ │ 公钥 (x,y)  │ │
│ │ 私钥        │ │──────────────▶│ │             │ │
│ │ (不可导出)  │ │              │ └─────────────┘ │
│ └─────────────┘ │              │        │        │
└─────────────────┘              │        ▼        │
                                 │ ┌─────────────┐ │
                                 │ │ P256VERIFY  │ │
                                 │ │ (0x100)     │ │
                                 │ └─────────────┘ │
                                 └─────────────────┘
```

---

## 10. 总结

### 10.1 密码学在区块链中的核心作用

```
┌─────────────────────────────────────────────────────────────┐
│                    区块链安全基石                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│    哈希函数          椭圆曲线          数字签名             │
│        │                 │                 │                │
│        ▼                 ▼                 ▼                │
│   ┌─────────┐      ┌─────────┐      ┌─────────┐            │
│   │ 数据    │      │ 密钥    │      │ 身份    │            │
│   │ 完整性  │      │ 生成    │      │ 验证    │            │
│   └─────────┘      └─────────┘      └─────────┘            │
│        │                 │                 │                │
│        └─────────────────┼─────────────────┘                │
│                          ▼                                  │
│                   ┌─────────────┐                          │
│                   │  无需信任   │                          │
│                   │  的价值转移 │                          │
│                   └─────────────┘                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 10.2 选择建议

| 场景         | 推荐曲线                | 理由     |
|------------|---------------------|--------|
| 兼容 BTC/ETH | secp256k1           | 生态兼容   |
| 高性能需求      | Ed25519             | 签名/验证快 |
| 硬件安全       | secp256r1           | 硬件支持广  |
| 用户友好       | secp256r1 (Passkey) | 生物识别   |

### 10.3 未来趋势

1. **账户抽象 (AA)**: 支持任意签名算法
2. **零知识证明**: 隐私保护
3. **后量子密码**: 抵抗量子计算攻击
4. **多方计算 (MPC)**: 分布式密钥管理
5. **Passkey 普及**: 降低 Web3 门槛

---

## 参考资料

- [Bitcoin Wiki - Secp256k1](https://en.bitcoin.it/wiki/Secp256k1)
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
- [Solana Documentation](https://docs.solana.com/)
- [EIP-7212: P256VERIFY](https://eips.ethereum.org/EIPS/eip-7212)
- [WebAuthn Specification](https://www.w3.org/TR/webauthn-2/)
- [Ed25519 Paper](https://ed25519.cr.yp.to/ed25519-20110926.pdf)
